console log border debug.txt
Document
last convo or border coloring.txt
Document
i am trying to add a new feature to my chrome extension to include coloring task borders, my implementation has not worked. can you see why from the logs? i also included my convo to see where i left off 
Thought for 3m 15s

Yep — the logs actually show your data + lookup path is working, but the “border” never becomes visible for two separate reasons:

1) You’re painting border-color, but the task chip likely has no visible border

Your popup preview explicitly sets a real border on the swatch chip:

target.chip.style.border = \2px solid ${color}`;` 

last convo or border coloring

…but in the content script, the logs indicate you’re applying a border color override (example #aa00ff) successfully:

pendingBorderColor: '#aa00ff' with a real listId 

console log border debug

If the actual Google Calendar task element has border-style: none (or border-width: 0), then setting only border-color does nothing visually.

✅ Fix: paint a real stroke, not just border-color. Best options:

Option A (recommended): use outline (no layout shift)
// inside applyPaint, after you decide borderColorToApply
const borderColorToApply = borderColorOverride || bgColorValue;

// save originals once
if (!node.dataset.cfGoogleOutline) {
  node.dataset.cfGoogleOutline = getComputedStyle(node).outline || '';
  node.dataset.cfGoogleOutlineOffset = getComputedStyle(node).outlineOffset || '';
}

node.style.setProperty('outline', `2px solid ${borderColorToApply}`, 'important');
node.style.setProperty('outline-offset', '-2px', 'important');
node.dataset.cfTaskBorderColor = borderColorToApply.toLowerCase();


And in clearPaint(node) restore/remove:

if (node.dataset.cfGoogleOutline) {
  node.style.setProperty('outline', node.dataset.cfGoogleOutline, 'important');
} else {
  node.style.removeProperty('outline');
}
if (node.dataset.cfGoogleOutlineOffset) {
  node.style.setProperty('outline-offset', node.dataset.cfGoogleOutlineOffset, 'important');
} else {
  node.style.removeProperty('outline-offset');
}
delete node.dataset.cfTaskBorderColor;

Option B: use box-shadow inset (also no layout shift, but must preserve existing shadow)
const cs = getComputedStyle(node);
if (!node.dataset.cfGoogleBoxShadow) node.dataset.cfGoogleBoxShadow = cs.boxShadow || 'none';

const base = node.dataset.cfGoogleBoxShadow;
const stroke = `inset 0 0 0 2px ${borderColorToApply}`;
node.style.setProperty('box-shadow', base && base !== 'none' ? `${stroke}, ${base}` : stroke, 'important');

2) Your “skip repaint” check ignores border, so border changes can be skipped

In your convo snapshot, applyPaintIfNeeded() returns early if bg/text match, without considering border: 

last convo or border coloring

That means: you can set a border later, but if the task is already marked + bg/text match, it may never repaint.

✅ Fix: include border in the “already painted” comparison:

const desiredBorder = (colors.borderColor || desiredBg).toLowerCase();
const currentBorder = (node.dataset.cfTaskBorderColor || '').toLowerCase();

if (
  node.classList.contains(MARK) &&
  currentBg === desiredBg &&
  currentText === desiredText &&
  currentBorder === desiredBorder
) return;


(And make sure applyPaint() sets node.dataset.cfTaskBorderColor to the actual applied value, like you do for bg/text.)

Bonus: small popup bug to fix

In the popup snippet, you assign currentBorderColor = value; but only currentBgColor and currentTextColor are declared nearby. 

last convo or border coloring


If that file/module is running in strict mode, this can throw or behave unpredictably.

✅ Fix: add:

let currentBorderColor = colorConfig.border;

What your logs prove (so you can stop chasing the wrong thing)

The border colors are in cache and are being resolved per list (hasBorderColorsInCache: true) 

console log border debug

At least some tasks have a valid listId and get pendingBorderColor: '#aa00ff' 

console log border debug

So the problem is primarily rendering + repaint logic, not storage or mapping.

If you paste your current applyPaint() border section + clearPaint() + applyPaintIfNeeded() (just those functions), I can give you a tight “drop-in” patch that uses outline and restores cleanly without breaking Google’s styles.

Sources
here is html of old ui and new ui tasks, does this help dignose the issue -

<div role="button" data-eventchip="" data-opens-details="true" tabindex="0" data-eventid="tasks_zdpMzHenPyvApm4l" data-keyboardactiontype="0;1" data-focusable="" jscontroller="NAKBTc" jsaction="click:cOuCgd; contextmenu:mg9Pef; dblclick:Reio8; mouseenter:tfO1Yc; mouseleave:JywGue;Bp7Oie:rfjeo;urdzG:Hu9wEd" jslog="185338; track:impression,click,dblclick,rfjeo,Hu9wEd" data-dragsource-type="2" class="GTG3wb ChfiMc rFUW1c LLspoc cf-task-colored" style="top: 139px; height: 18px; left: calc(0% + 0px); width: calc(100% + 0px); z-index: 5; background-color: rgb(76, 175, 80) !important; border-color: rgb(170, 0, 255) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important; --cf-task-text-color: rgba(255, 87, 34, 1) !important; color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important;" data-cf-google-bg="rgb(252, 248, 232)" data-cf-google-bg-was-completed="false" data-cf-google-border="rgb(228, 196, 65)" data-cf-google-text="rgb(31, 31, 31)" data-cf-task-text-color="#ff5722" data-cf-task-bg-color="rgb(76, 175, 80)" data-cf-task-border-color="#aa00ff" data-cf-task-text-actual="rgba(255, 87, 34, 1)"><div class="QZVPzb" aria-hidden="true" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><div class="jSrjCf" style="background-color: rgb(228, 196, 65); color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"></div></div><div class="XuJrye" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;">task: EF, Not completed, January 6, 2026, 3:30am</div><div aria-hidden="true" class="Jcb6qd AL18ce" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><div class="FGo AL18ce" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><div class="bgr46c" jsaction="JIbuQc:Vse0zf(nWuQKb)" jslog="87527; track:click; mutable:true;" jscontroller="hgGok" data-eventid="tasks_zdpMzHenPyvApm4l" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><button class="pYTkkf-Bz112c-LgbsSe CPXyj qeMtzb AL18ce LLspoc TuM9nf ouqA7d HA9jxf" jscontroller="PIVayb" jsaction="click:h5M12e;clickmod:h5M12e;pointerdown:FEiYhc;pointerup:mF5Elf;pointerenter:EX0mI;pointerleave:vpvbp;pointercancel:xyn4sd;contextmenu:xexox;focus:h06R8; blur:zjh6rb;mlnRJb:fLiPzd" data-idom-class="CPXyj qeMtzb AL18ce LLspoc TuM9nf ouqA7d HA9jxf" data-use-native-focus-logic="true" jsname="nWuQKb" aria-label="Mark complete" tabindex="-1" aria-hidden="true"><span class="XjoK4b pYTkkf-Bz112c-UHGRz" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"></span><span class="UTNHae" jscontroller="LBaJxb" jsname="m9ZlFb" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"></span><span jsname="S5tZuc" aria-hidden="true" class="pYTkkf-Bz112c-kBDsod-Rtc0Jf" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><span class="notranslate VfPpkd-kBDsod" aria-hidden="true" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><span class="notranslate CPXyj qeMtzb AL18ce LLspoc TuM9nf ouqA7d NV3tib" aria-hidden="true" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><svg focusable="false" width="14" height="14" viewBox="0 0 24 24" class="jB5sh ykyZxc NMm5M" style="color: rgb(255, 87, 34) !important; fill: rgb(255, 87, 34) !important; opacity: 1 !important;"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path></svg></span><span class="notranslate CPXyj qeMtzb AL18ce LLspoc TuM9nf ouqA7d kKIV3" aria-hidden="true" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><svg enable-background="new 0 0 24 24" focusable="false" height="14" viewBox="0 0 24 24" width="14" class="jB5sh ykyZxc NMm5M" style="color: rgb(255, 87, 34) !important; fill: rgb(255, 87, 34) !important; opacity: 1 !important;"><rect fill="none" height="24" width="24"></rect><path d="M22,5.18L10.59,16.6l-4.24-4.24l1.41-1.41l2.83,2.83l10-10L22,5.18z M19.79,10.22C19.92,10.79,20,11.39,20,12 c0,4.42-3.58,8-8,8s-8-3.58-8-8c0-4.42,3.58-8,8-8c1.58,0,3.04,0.46,4.28,1.25l1.44-1.44C16.1,2.67,14.13,2,12,2C6.48,2,2,6.48,2,12 c0,5.52,4.48,10,10,10s10-4.48,10-10c0-1.19-0.22-2.33-0.6-3.39L19.79,10.22z"></path></svg></span></span></span><div class="pYTkkf-Bz112c-RLmnJb" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"></div></button></div></div><div class="fFwDnf" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><div class="lhydbb RIOtYe cpCWFd PKhkGc LLspoc TuM9nf" style="max-height: 15px; color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><span class="KcY3wb" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><span class="I0UMhf" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;">EF</span><span class="pttLke" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;">,&nbsp;</span><span class="EWOIrf" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;">3:30am</span></span></div></div></div></div>


<div role="button" data-eventchip="" data-opens-details="true" tabindex="0" data-eventid="ttb_MWZzdDFqcHQyMHUxcGhpcDdmanM0b2lqZXAgYWRhbS5odXJsZXkucHJpdmF0ZUBt" data-keyboardactiontype="0;1" data-focusable="" jscontroller="NAKBTc" jsaction="click:cOuCgd; contextmenu:mg9Pef; dblclick:Reio8; mouseenter:tfO1Yc; mouseleave:JywGue;Bp7Oie:rfjeo;urdzG:Hu9wEd" jslog="185338;2:[&quot;1fst1jpt20u1phip7fjs4oijep&quot;,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,19];track:impression,click,dblclick,rfjeo,Hu9wEd" data-dragsource-type="2" class="GTG3wb ChfiMc rFUW1c LLspoc afiDFd cf-task-colored" style="top: 129px; height: 38px; left: calc(0% + 0px); width: calc(100% + 0px); z-index: 5; background-color: rgb(76, 175, 80) !important; border-color: rgb(170, 0, 255) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important; --cf-task-text-color: rgba(255, 87, 34, 1) !important; color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important;" data-cf-google-bg="rgb(252, 248, 232)" data-cf-google-bg-was-completed="false" data-cf-google-border="rgb(228, 196, 65)" data-cf-google-text="rgb(31, 31, 31)" data-cf-task-text-color="#ff5722" data-cf-task-bg-color="rgb(76, 175, 80)" data-cf-task-border-color="#aa00ff" data-cf-task-text-actual="rgba(255, 87, 34, 1)"><div class="QZVPzb" aria-hidden="true" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><div class="jSrjCf" style="background-color: rgb(228, 196, 65); color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"></div></div><div class="XuJrye" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;">task: sth, Not completed, January 5, 2026, 3:15am to 4:15am</div><div aria-hidden="true" class="Jcb6qd" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><div class="FGo" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><div class="bgr46c" jsaction="JIbuQc:Vse0zf(nWuQKb)" jslog="87527; track:click; mutable:true;" jscontroller="hgGok" data-eventid="ttb_MWZzdDFqcHQyMHUxcGhpcDdmanM0b2lqZXAgYWRhbS5odXJsZXkucHJpdmF0ZUBt" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><button class="pYTkkf-Bz112c-LgbsSe CPXyj qeMtzb LLspoc TuM9nf ouqA7d HA9jxf" jscontroller="PIVayb" jsaction="click:h5M12e;clickmod:h5M12e;pointerdown:FEiYhc;pointerup:mF5Elf;pointerenter:EX0mI;pointerleave:vpvbp;pointercancel:xyn4sd;contextmenu:xexox;focus:h06R8; blur:zjh6rb;mlnRJb:fLiPzd" data-idom-class="CPXyj qeMtzb LLspoc TuM9nf ouqA7d HA9jxf" data-use-native-focus-logic="true" jsname="nWuQKb" aria-label="Mark complete" tabindex="-1" aria-hidden="true"><span class="XjoK4b pYTkkf-Bz112c-UHGRz" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"></span><span class="UTNHae" jscontroller="LBaJxb" jsname="m9ZlFb" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"></span><span jsname="S5tZuc" aria-hidden="true" class="pYTkkf-Bz112c-kBDsod-Rtc0Jf" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><span class="notranslate VfPpkd-kBDsod" aria-hidden="true" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><span class="notranslate CPXyj qeMtzb LLspoc TuM9nf ouqA7d NV3tib" aria-hidden="true" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><svg focusable="false" width="14" height="14" viewBox="0 0 24 24" class="jB5sh ykyZxc NMm5M" style="color: rgb(255, 87, 34) !important; fill: rgb(255, 87, 34) !important; opacity: 1 !important;"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path></svg></span><span class="notranslate CPXyj qeMtzb LLspoc TuM9nf ouqA7d kKIV3" aria-hidden="true" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><svg enable-background="new 0 0 24 24" focusable="false" height="14" viewBox="0 0 24 24" width="14" class="jB5sh ykyZxc NMm5M" style="color: rgb(255, 87, 34) !important; fill: rgb(255, 87, 34) !important; opacity: 1 !important;"><rect fill="none" height="24" width="24"></rect><path d="M22,5.18L10.59,16.6l-4.24-4.24l1.41-1.41l2.83,2.83l10-10L22,5.18z M19.79,10.22C19.92,10.79,20,11.39,20,12 c0,4.42-3.58,8-8,8s-8-3.58-8-8c0-4.42,3.58-8,8-8c1.58,0,3.04,0.46,4.28,1.25l1.44-1.44C16.1,2.67,14.13,2,12,2C6.48,2,2,6.48,2,12 c0,5.52,4.48,10,10,10s10-4.48,10-10c0-1.19-0.22-2.33-0.6-3.39L19.79,10.22z"></path></svg></span></span></span><div class="pYTkkf-Bz112c-RLmnJb" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"></div></button></div></div><div class="fFwDnf" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><div class="lhydbb RIOtYe cpCWFd LLspoc TuM9nf" style="max-height: 15px; color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><span class="KcY3wb" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"><span class="I0UMhf" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;">sth</span></span></div><div class="lhydbb gVNoLb  LLspoc TuM9nf" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;">3:15 – 4:15am</div></div></div><div aria-hidden="true" jsaction="mouseover:in2ji; mouseout:in2ji" class="leOeGd ChfiMc YVffPe" data-eventid="ttb_MWZzdDFqcHQyMHUxcGhpcDdmanM0b2lqZXAgYWRhbS5odXJsZXkucHJpdmF0ZUBt" data-dragsource-type="3" jscontroller="G9NlD" style="color: rgb(255, 87, 34) !important; -webkit-text-fill-color: rgb(255, 87, 34) !important; text-decoration-color: rgb(255, 87, 34) !important; mix-blend-mode: normal !important; filter: none !important; opacity: 1 !important;"></div></div>
Thought for 39s

Yes — this HTML basically confirms the diagnosis.

What the HTML proves

In both the “old” and “new” task chips, your script successfully injects:

style="... border-color: rgb(170, 0, 255) !important; ..."


…but nothing in that element’s inline style sets border-width or border-style (or a shorthand border:). So if Google’s CSS has (very likely) something like:

border-style: none; or

border-width: 0px;

…then border-color is a no-op visually.

That’s exactly why your logs show “border color resolved + applied”, yet you “see nothing”.

Old vs new UI: what changed (and why it doesn’t change the border outcome)

The new UI chip adds an extra class (afiDFd) and an extra trailing element:

<div class="leOeGd ChfiMc YVffPe" ...></div>


That’s a new overlay/handle-ish element, but it doesn’t matter: your border-color is still being applied to the outer chip div, and it still won’t render without an actual border stroke.

Fast proof in DevTools (do this on a task chip)

Click the task chip in Elements, then run:

getComputedStyle($0).borderTopWidth
getComputedStyle($0).borderTopStyle
getComputedStyle($0).borderTopColor


If you see 0px or none, that’s your entire problem.

The fix (don’t use border-color alone)

You want a border effect that:

is always visible,

doesn’t shift layout,

survives Google’s UI updates.

Best option: inset box-shadow “stroke” (no layout shift)

In your applyPaint():

const borderColorToApply = (borderColorOverride || bgColorValue).toLowerCase();

const cs = getComputedStyle(node);
if (!node.dataset.cfGoogleBoxShadow) node.dataset.cfGoogleBoxShadow = cs.boxShadow || '';

const baseShadow = node.dataset.cfGoogleBoxShadow;
const stroke = `inset 0 0 0 2px ${borderColorToApply}`;
const combined = baseShadow && baseShadow !== 'none' ? `${stroke}, ${baseShadow}` : stroke;

node.style.setProperty('box-shadow', combined, 'important');
node.dataset.cfTaskBorderColor = borderColorToApply;


And in clearPaint(node):

if (node.dataset.cfGoogleBoxShadow !== undefined) {
  const v = node.dataset.cfGoogleBoxShadow;
  if (v) node.style.setProperty('box-shadow', v, 'important');
  else node.style.removeProperty('box-shadow');
  delete node.dataset.cfGoogleBoxShadow;
}
delete node.dataset.cfTaskBorderColor;

Also fix your “skip repaint” logic

If you skip repaint when bg/text match, border may never update.

Make the early-return check include border too:

const desiredBorder = (colors.borderColor || desiredBg).toLowerCase();
const currentBorder = (node.dataset.cfTaskBorderColor || '').toLowerCase();

if (marked && currentBg === desiredBg && currentText === desiredText && currentBorder === desiredBorder) return;

One more useful observation from your HTML

You have a child:

<div class="QZVPzb"><div class="jSrjCf" style="background-color: rgb(228, 196, 65)"></div></div>


That jSrjCf is the little “accent strip / indicator”. If you ever decide you want a left-bar color feature, that’s the element to paint — but for a full border, the inset shadow approach is the reliable one.

If you paste your current applyPaint(), clearPaint(), and applyPaintIfNeeded() (just those three), I’ll rewrite them as a clean drop-in patch that uses inset border + correct restore + correct repaint skipping.

Fast proof in DevTools (do this on a task chip)

Click the task chip in Elements, then run:

getComputedStyle($0).borderTopWidth
getComputedStyle($0).borderTopStyle
getComputedStyle($0).borderTopColor


explain how to do this so we can verify the right fixes needed 

Sure — here’s the exact “click + run + interpret” flow in Chrome DevTools.

1) Open DevTools and select the task chip element

Go to Google Calendar where the task chip is visible.

Open DevTools:

Windows/Linux: Ctrl + Shift + I

Mac: Cmd + Option + I

Click the element picker icon (top-left of DevTools, looks like a cursor in a box)
or press Ctrl + Shift + C (Cmd + Shift + C on Mac).

Hover the task chip in the calendar and click it.

The chip <div role="button" data-eventchip ...> should now be highlighted in the Elements panel.

Important: In the Elements panel, make sure the selected node is the outer chip div (the one with role="button" and your cf-task-colored class).

2) Run the computed-style checks in the Console

Go to the Console tab in DevTools.

Paste these three lines and press Enter after each (or paste all at once):

getComputedStyle($0).borderTopWidth
getComputedStyle($0).borderTopStyle
getComputedStyle($0).borderTopColor

What $0 means

$0 is Chrome’s shortcut for “the currently selected element in the Elements panel”.

So as long as you clicked the task chip in Elements, $0 will refer to it.

3) Interpret the results (this tells us what fix is needed)

You’ll see results like:

Case A — border is effectively “off”

borderTopWidth → "0px"

borderTopStyle → "none" (or "hidden")

✅ Meaning: setting border-color won’t show anything.
You must use:

outline, or

box-shadow: inset 0 0 0 2px ..., or

set border: 2px solid ... (but that can cause layout shift)

Case B — border exists, so border-color should show

borderTopWidth → "1px" (or "2px")

borderTopStyle → "solid"

✅ Meaning: your border-color should become visible if nothing overlays it.
If you still don’t see it, likely:

a child overlay is covering edges, or

overflow: hidden + border radius + layering, or

your repaint logic isn’t running when border changes

4) Optional: prove the fix interactively (no code changes yet)

With the chip still selected, run one of these:

Test outline (easy)
$0.style.setProperty('outline', '2px solid #aa00ff', 'important');
$0.style.setProperty('outline-offset', '-2px', 'important');

Test inset stroke (my preferred)
$0.style.setProperty('box-shadow', 'inset 0 0 0 2px #aa00ff', 'important');


If either of these shows a border immediately, you’ve confirmed the right direction.

If you tell me what the three getComputedStyle($0)... lines return, I’ll tell you exactly which implementation (border vs outline vs inset shadow) is the cleanest for that specific chip.

getComputedStyle($0).borderTopWidth
getComputedStyle($0).borderTopStyle
getComputedStyle($0).borderTopColor

'rgb(255, 87, 34)'
$0.style.setProperty('box-shadow', 'inset 0 0 0 2px #aa00ff', 'important');

undefined

after running this i can see the task has the border color correctly 



Thought for 26s

Perfect — that’s the key verification.

Why you saw undefined

style.setProperty(...) returns undefined by design (it’s not an error). The proof is visual: you saw the border stroke appear, so the approach works.

What your result means

Your current implementation sets:

border-color: ... !important

…but the chip’s actual border is effectively not rendered (border width/style not giving you a visible stroke). So border-color alone will never show.

By forcing:

box-shadow: inset 0 0 0 2px #aa00ff


you created a visible “border” that doesn’t depend on border width/style. ✅ That’s the correct fix direction.

What to change in your extension code
1) Replace “border-color” painting with an inset stroke

Where you currently do something like:

node.style.setProperty('border-color', borderColorToApply, 'important');


Replace/augment it with:

const borderColorToApply = (borderColorOverride || bgColorValue).toLowerCase();

// Save original box-shadow once so we can restore
if (node.dataset.cfGoogleBoxShadow === undefined) {
  node.dataset.cfGoogleBoxShadow = getComputedStyle(node).boxShadow || '';
}

const base = node.dataset.cfGoogleBoxShadow;
const stroke = `inset 0 0 0 2px ${borderColorToApply}`;
const combined = base && base !== 'none' ? `${stroke}, ${base}` : stroke;

node.style.setProperty('box-shadow', combined, 'important');
node.dataset.cfTaskBorderColor = borderColorToApply;

2) Update your “skip repaint” logic to include border

If you do an early return when bg/text already match, you must also check border:

const desiredBorder = (colors.borderColor || desiredBg).toLowerCase();
const currentBorder = (node.dataset.cfTaskBorderColor || '').toLowerCase();

if (alreadyMarked && currentBg === desiredBg && currentText === desiredText && currentBorder === desiredBorder) {
  return;
}

3) Restore cleanly in clearPaint()
if (node.dataset.cfGoogleBoxShadow !== undefined) {
  const v = node.dataset.cfGoogleBoxShadow;
  if (v) node.style.setProperty('box-shadow', v, 'important');
  else node.style.removeProperty('box-shadow');
  delete node.dataset.cfGoogleBoxShadow;
}
delete node.dataset.cfTaskBorderColor;

One quick extra verification (optional)

With the task selected, run:

getComputedStyle($0).boxShadow


If it’s "none" normally, then using box-shadow as the border is very safe.

If you paste your current applyPaint() / clearPaint() / applyPaintIfNeeded() blocks, I’ll rewrite them into a single drop-in patch with zero duplication, correct restore, and no “repaint skipped” edge-cases.

getComputedStyle($0).boxShadow

'none'

Nice — that’s the best-case result.

Since getComputedStyle($0).boxShadow is 'none', you can safely use an inset box-shadow stroke as your “border” without worrying about clobbering Google’s own shadows (because there aren’t any on that chip right now).

What this confirms

Your current border-color approach won’t reliably show (because the chip isn’t using a visible border).

The correct implementation is: paint a border using box-shadow: inset ....

Drop-in logic you should use

In your paint function:

const borderColorToApply = (borderColorOverride || bgColorValue).toLowerCase();

// Save original shadow once
if (node.dataset.cfGoogleBoxShadow === undefined) {
  node.dataset.cfGoogleBoxShadow = getComputedStyle(node).boxShadow || '';
}

const stroke = `inset 0 0 0 2px ${borderColorToApply}`;

// If someday Google adds a shadow, preserve it
const base = node.dataset.cfGoogleBoxShadow;
const combined = base && base !== 'none' ? `${stroke}, ${base}` : stroke;

node.style.setProperty('box-shadow', combined, 'important');
node.dataset.cfTaskBorderColor = borderColorToApply;


And in your clear/unpaint:

if (node.dataset.cfGoogleBoxShadow !== undefined) {
  const original = node.dataset.cfGoogleBoxShadow;
  if (original && original !== 'none') node.style.setProperty('box-shadow', original, 'important');
  else node.style.removeProperty('box-shadow');
  delete node.dataset.cfGoogleBoxShadow;
}
delete node.dataset.cfTaskBorderColor;

One crucial follow-up

Make sure your “skip repaint” check also includes border, otherwise border changes may not apply on already-painted chips.

If you want, paste your applyPaintIfNeeded() early-return block and I’ll edit it to include border in the comparison.

$0.style.setProperty('outline', '2px solid #aa00ff', 'important');
$0.style.setProperty('outline-offset', '-2px', 'important');

undefined
$0.style.setProperty('outline', '2px solid #aa00ff', 'important');
$0.style.setProperty('outline-offset', '-2px', 'important');

undefined
getComputedStyle($0).boxShadow

'none'
$0.style.setProperty('outline', '2px solid #aa00ff', 'important');
$0.style.setProperty('outline-offset', '-2px', 'important');

undefined
getComputedStyle($0).boxShadow
'none'


this also worked correctly for new ui task, previous ones i provided were recurring old ui tasks so the fix works on both  

Awesome — that confirms you’ve got two reliable rendering options that work on both UIs:

outline + outline-offset ✅

box-shadow: inset ... ✅

And yep: all those undefined lines are normal (same reason as before: setProperty() returns nothing).

Which should you ship?

I’d ship outline as the default for “task border”, because:

it doesn’t interact with any future box-shadow Google might add

it’s very stable visually

it avoids any “shadow stacking” edge cases

Recommended implementation (outline)

In your applyPaint() (or wherever you apply colors):

const borderColorToApply = (borderColorOverride || bgColorValue).toLowerCase();

// store originals once
if (node.dataset.cfGoogleOutline === undefined) {
  const cs = getComputedStyle(node);
  node.dataset.cfGoogleOutline = cs.outline || '';
  node.dataset.cfGoogleOutlineOffset = cs.outlineOffset || '';
}

node.style.setProperty('outline', `2px solid ${borderColorToApply}`, 'important');
node.style.setProperty('outline-offset', '-2px', 'important');
node.dataset.cfTaskBorderColor = borderColorToApply;


In clearPaint(node):

if (node.dataset.cfGoogleOutline !== undefined) {
  const o = node.dataset.cfGoogleOutline;
  if (o && o !== 'none') node.style.setProperty('outline', o, 'important');
  else node.style.removeProperty('outline');
  delete node.dataset.cfGoogleOutline;
}

if (node.dataset.cfGoogleOutlineOffset !== undefined) {
  const oo = node.dataset.cfGoogleOutlineOffset;
  if (oo) node.style.setProperty('outline-offset', oo, 'important');
  else node.style.removeProperty('outline-offset');
  delete node.dataset.cfGoogleOutlineOffset;
}

delete node.dataset.cfTaskBorderColor;

Don’t forget: repaint-skip must include border

If you have a fast-path like “already painted + bg/text match => return”, you must include border too, or border changes won’t apply:

const desiredBorder = (colors.borderColor || desiredBg).toLowerCase();
const currentBorder = (node.dataset.cfTaskBorderColor || '').toLowerCase();

if (marked && currentBg === desiredBg && currentText === desiredText && currentBorder === desiredBorder) {
  return;
}

Quick sanity check after you patch

After your extension paints a task, select the chip and run:

getComputedStyle($0).outline
getComputedStyle($0).outlineOffset


You should see something like:

"rgb(170, 0, 255) solid 2px"

"-2px"

If you paste your current applyPaintIfNeeded() early-return block + your current border painting lines, I’ll rewrite that section into an exact drop-in patch matching your existing dataset keys (data-cf-task-border-color, etc.) so it plugs in cleanly.

summarise fixes needed to color the tasks correctly using the outline method 

Here’s the minimal set of fixes to make task border coloring work reliably using outline.

1) Stop using border-color for the “border”

border-color won’t show unless the element has a real border width/style. Instead, apply an outline stroke.

2) In your paint/apply function, set outline + outline-offset

Use your chosen border color (override if present, otherwise fall back to bg):

const borderColorToApply = (borderColorOverride || bgColorValue).toLowerCase();

// Save originals once (for clean restore)
if (node.dataset.cfGoogleOutline === undefined) {
  const cs = getComputedStyle(node);
  node.dataset.cfGoogleOutline = cs.outline || '';
  node.dataset.cfGoogleOutlineOffset = cs.outlineOffset || '';
}

// Apply visible border stroke
node.style.setProperty('outline', `2px solid ${borderColorToApply}`, 'important');
node.style.setProperty('outline-offset', '-2px', 'important');

// Track what we applied (for skip logic + debugging)
node.dataset.cfTaskBorderColor = borderColorToApply;

3) In your clear/unpaint function, restore originals
if (node.dataset.cfGoogleOutline !== undefined) {
  const o = node.dataset.cfGoogleOutline;
  if (o && o !== 'none') node.style.setProperty('outline', o, 'important');
  else node.style.removeProperty('outline');
  delete node.dataset.cfGoogleOutline;
}

if (node.dataset.cfGoogleOutlineOffset !== undefined) {
  const oo = node.dataset.cfGoogleOutlineOffset;
  if (oo) node.style.setProperty('outline-offset', oo, 'important');
  else node.style.removeProperty('outline-offset');
  delete node.dataset.cfGoogleOutlineOffset;
}

delete node.dataset.cfTaskBorderColor;

4) Update your “skip repaint” check to include border

If you currently early-return when bg/text already match, you must also compare border, otherwise border updates won’t apply:

const desiredBorder = (colors.borderColor || desiredBg).toLowerCase();
const currentBorder = (node.dataset.cfTaskBorderColor || '').toLowerCase();

if (marked && currentBg === desiredBg && currentText === desiredText && currentBorder === desiredBorder) return;


That’s it: paint outline, restore outline, and don’t skip repaint unless border matches too.
